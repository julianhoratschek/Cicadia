#include "database.h"
#include "database.h"


CCDataBase::CCDataBase()
{
    db = QSqlDatabase::addDatabase("SQLITE3");
    db.setDatabaseName("cicadia.db");
    db.open();

    db.exec("create table if not exists `Subject` (`ID` integer primary key, `Name` text)");
    db.exec("create table if not exists `SubjectMeta` (`Subject_ID` integer, `First_Name` text, `Last_Name` text, `Gender` boolean, `Age` integer)");
    db.exec("create table if not exists `GroupRelations` (`Group_ID` integer, `Subject_ID` integer)");
    db.exec("create table if not exists `Data` (`ID` integer, `Time` datetime, `Value` real, `Used` boolean)");
    db.exec("create table if not exists `Dataset` (`ID` integer primary key auto_increment, `Parent_ID` integer, `Data_ID` integer, `Start` datetime, `End` datetime, `Suffix` text, `Color` integer, `Type` integer)");
    db.exec("create table if not exists `DatasetRelations` (`Subject_ID` integer, `Dataset_ID` integer)");
}


CCDataBase::~CCDataBase()
{
    db.close();
}


CCDataSetPtr CCDataBase::importFromFile(const QString &fileName)
{
    QFileInfo           info(fileName);
    QFile               fl(fileName);
    QTextStream         stream(&fl);
    CCDataPtr           data(new CCData(""));


    if(info.suffix() != "csv")
        return {};

    if(!fl.open(QIODevice::ReadOnly | QIODevice::Text))
        return {};

    // Make sure, CSV-File is generated by 1-Wire
    if(stream.readLine().left(14) != "1-Wire/iButton") {
        fl.close();
        return {};
    }

    // Read iButton-ID as Name for Subject
    data->name = stream.readLine().right(16) + info.baseName();

    for(int lineNum = 3; !stream.atEnd(); lineNum++) {
        QString         line = stream.readLine();

        // Skip unnecessary lines
        if(lineNum < 16)
            continue;

        // Split Columns by "," into l[0] = DateTime, l[1] = "C", l[2] = Temp, (l[3] = Temp floating point)
        QStringList     l = line.split(",");
        QDateTime       dt = QDateTime::fromString(l[0], "dd.MM.yy HH:mm:ss");

        dt = cleanTime(dt);

        // Qt can't handle two-digit years over 1999
        dt = dt.addYears(100);
        //dt.setTimeSpec(Qt::UTC);

        // Circumvents Error in 1-Wire CSV-File
        data->internal[dt.toSecsSinceEpoch()] = l.size() == 4 ? QString( l[2] + "." + l[3] ).toDouble() :
                                                l[2].toDouble();
    }

    fl.close();

    //autoInsertMarkers(data); // TODO

    return insertData(data);
}


QVector<CCSubject> CCDataBase::selectSubjects()
{
    QVector<CCSubject>      ret;
    QSqlQuery               q(db);

    q.prepare("select `ID`, `Name`, count(`Group_ID`) as `isGroup` from `Subject` join `GroupRelations` on `ID` = `Subject_ID` group by `Group_ID`");
    if(!q.exec())
        return {};
    while(q.next()) {
        CCSubject   s(  q.value("ID").toInt(),
                        q.value("Name").toString(),
                        q.value("isGroup").toBool());
        ret << s;
    }

    return ret;
}


QVector<QSharedPointer<CCDataSet> > CCDataBase::selectDatasets(int subjectId)
{
    QVector<CCDataSetPtr>       ret;
    QSqlQuery                   q(db);

    q.prepare("select `Dataset`.`ID` as `DsID`, `Parent_ID`, `Data_ID`, `Start`, `End`, `Suffix`, `Color`, `Type` from `Dataset`, `DatasetRelations` where `Subject_ID` = ? and `Dataset`.`ID` = `Dataset_ID`");
    q.addBindValue(subjectId);
    if(!q.exec())
        return {};

    while(q.next())
        ret << addDataset(q);

    return ret;
}


QSharedPointer<CCDataSet> CCDataBase::selectDataset(int datasetId)
{
    QSqlQuery               q(db);

    if(datasets.contains(datasetId))
        return datasets[datasetId];

    q.prepare("select `ID` as `DsID`, `Parent_ID`, `Data_ID`, `Start`, `End`, `Suffix`, `Color`, `Type` from `Dataset` where `ID` = ?");
    q.addBindValue(datasetId);
    if(!q.exec() || !q.next())
        return {};

    return addDataset(q);
}


QSharedPointer<CCData> CCDataBase::selectData(int dataId)
{
    if(data.contains(dataId))
        return data[dataId];

    QSqlQuery               q(db);

    q.prepare("select `Name` from `Subject` where `ID` = ?");
    q.addBindValue(dataId);
    if(!q.exec() || !q.next())
        return nullptr;

    CCDataPtr               dt(new CCData(q.value("Name").toString()));

    q.prepare("select `Time`, `Value`, `Used` from `Data` where `ID` = ?");
    q.addBindValue(dataId);
    if(!q.exec())
        return nullptr;

    qint64      mean = 0;
    while(q.next()) {
        mean += q.value("Time").toLongLong();
        if(q.value("Used").toBool())
            dt->internal.insert(q.value("Time").toLongLong(), q.value("Value").toDouble());
    }

    dt->interval = mean / dt->internal.size();
    data.insert(dataId, dt);

    return dt;
}


QSharedPointer<CCDataSet> CCDataBase::insertDataset(QSharedPointer<CCDataSet> dataset, int subjectId)
{
    QSqlQuery           q(db);

    beginOperation;

    q.prepare("insert into `Dataset` (`Parent_ID`, `Data_ID`, `Start`, `End`, `Suffix`, `Color`, `Type`) values (?, ?, ?, ?, ?, ?, ?)");
    q.addBindValue(dataset->getParentId());
    q.addBindValue(dataset->getDataId());
    q.addBindValue(dataset->from());
    q.addBindValue(dataset->to());
    q.addBindValue(dataset->getSuffix());
    q.addBindValue(dataset->getColor());
    q.addBindValue(dataset->getType());
    execOperation(nullptr)

    dataset->setId(q.lastInsertId().toInt());

    q.prepare("insert into `DatasetRelations` (`Subject_ID`, `Dataset_ID`) values (?, ?)");
    q.addBindValue(subjectId);
    q.addBindValue(dataset->getId());
    execOperation(nullptr)

    endOperation;

    return dataset;
}


QSharedPointer<CCDataSet> CCDataBase::insertData(QSharedPointer<CCData> data, int parentId, const QString &suffix, const QColor &color, CCDataSet::DataType type)
{
    QSqlQuery           q(db);

    beginOperation;

    q.prepare("insert into `Dataset` (`Parent_ID`, `Data_ID`, `Start`, `End`, `Suffix`, `Color`, `Type`) values (?, `ID`, ?, ?, ?, ?, ?)");
    q.addBindValue(parentId);
    q.addBindValue(data->internal.firstKey());
    q.addBindValue(data->internal.lastKey());
    q.addBindValue(suffix);
    q.addBindValue(color);
    q.addBindValue(type);
    execOperation(nullptr)

    int                 id = q.lastInsertId().toInt();

    q.prepare("insert into `Subject` (`ID`, `Name`) values (?, ?)");
    q.addBindValue(id);
    q.addBindValue(data->name);
    execOperation(nullptr)

    q.prepare("insert into `DatasetRelations` (`Subject_ID`, `Dataset_ID`) values (?, ?)");
    q.addBindValue(id);
    q.addBindValue(id);
    execOperation(nullptr)

    for(auto it = data->internal.begin(); it != data->internal.end(); it++) {
        q.prepare("insert into `Data` (`ID`, `Time`, `Value`, `Used`) values (?, ?, ?, true)");
        q.addBindValue(id);
        q.addBindValue(it.key());
        q.addBindValue(it.value());
        execOperation(nullptr)
    }

    endOperation;

    return selectDataset(id);
}


int CCDataBase::updateDataset(const CCDataSet &dataset)
{
    QSqlQuery               q(db);

    q.prepare("update `Dataset` set `Suffix` = ?, `Color` = ? where `ID` = ?");
    q.addBindValue(dataset.getSuffix());
    q.addBindValue(dataset.getColor());
    q.addBindValue(dataset.getId());
    if(!q.exec())
        return false;

    return true;
}


QSharedPointer<CCDataSet> CCDataBase::addDataset(const QSqlQuery &q)
{
    int                 id = q.value("DsID").toInt();

    if(!datasets.contains(id)) {
        CCDataSetPtr        ds(new CCDataSet(id, q.value("Parent_ID").toInt()));

        ds->setDataId(q.value("Data_ID").toInt());
        ds->setRange(q.value("Start").toLongLong(), q.value("End").toLongLong());
        ds->setSuffix(q.value("Suffix").toString());
        ds->setColor(QRgb(q.value("Color").toInt()));
        ds->setType(q.value("Type").toInt());

        datasets.insert(id, ds);
    }

    return datasets[id];
}


QDateTime CCDataBase::cleanTime(const QDateTime &dt) const
{
    int         mindiff = dt.time().minute() % 10;

    if(mindiff != 0) {
        if(mindiff < 5)
            return dt.addSecs(mindiff * -60);
        return dt.addSecs(600 - (mindiff * 60));
    }

    return dt;
}























